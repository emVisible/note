# 网络类

<img src="C:\Users\16193\AppData\Roaming\Typora\typora-user-images\image-20230710143828900.png" alt="image-20230710143828900" style="zoom:67%;" />

<img src="C:\Users\16193\AppData\Roaming\Typora\typora-user-images\image-20230710144031221.png" alt="image-20230710144031221" style="zoom:67%;" />

## 三次握手与四次挥手

- 三次握手

  ```
  SYN
  ACK SYN
  ACK
  ```

  

- 四次挥手为什么是四次，三次不行吗？

  ```
  ·报文段1：
  	A FIN。
  	主动关闭方向被动关闭方发送结束报文段。
  ·报文段2：
  	B ACK
  	被动关闭方发送结束报文段确认，此时主动关闭方数据已经传输完毕。
  ·报文段3：
  	B FIN ACK
  	被动关闭方数据也发送完毕，发送结束报文段。
  ·报文段4：
  	A ACK
  	closed
  	主动关闭方对结束报文段进行确认。
  
  ACK用来应答，SYN用来同步
  关键在于第二段挥手。Server段只发送ACK，意思是我收到了结束请求。而服务端是可以一下子发送FIN和ACK的，但是第二段挥手没有一次性发完是因为，我现在身上还有活，等我忙完了我再发FIN和ACK。类比聚餐，朋友打来电话要你现在来，而自己还有些活没忙完，这时候你会说“等我忙完了再过去”是一个道理。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。
  ```

## HTTP基础

> http请求的方法，说说put，这样做为了什么规范
>
> https和http ？讲了混合加密过程和ssl证书数字签名等等。





## HTTP缓存 

缓存本身是计算机的内存，同时开辟硬盘作为数据存储区域，通过这块区域来缓存信息

HTTP缓存=浏览器缓存+服务器缓存

### 前端缓存

Cookie，localStorage，SessionSotrage，IndexedDB

- Cookie：4KB、每次请求都会加在请求头里、非敏感信息、浏览器关闭消失
- localStorage：5MB、永久、同步、同源限制
- SessionSotage：5MB、会话、同步、同源限制
- IndexedDB：5-50MB、对象存储、异步请求、同源限制、并发限制

### 后端缓存

方式：HTTP主要通过请求和相应Header来控制缓存，缩短网络请求距离

优点：

- 节省流量
- 降低网络负荷
- 提高响应速度

分类(是否需要重新向服务器发送请求)

- 强缓存 (直接读取缓存，返回200)

  由header中的Pragma、Cache-Control、Expires控制

- 协商缓存 (重新发送请求，返回304)

  由header中的Etag和LastModified控制

*用户行为

- 新页面、前进、后退: 均有效

- F5: 仅对协商缓存有效

- ctrl+f5:均无效

### 问题

同一url的两个页面会共享localStorage和sessionStorage吗？ local共享、session不共享

如何设置禁用缓存？

```
服务端:
	设置Nginx && Apache的header——Cache-Control
客户端:
	浏览器 && devtool禁用
	meta标签设置禁用
		<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
		<meta http-equiv="Pragma" content="no-cache" />
		<meta http-equiv="Expires" content="0" />
```

## 跨域

> 跨域问题有遇到过吗？怎么解决的呢？实际项目和实习中遇到是怎么解决的？

跨域可以设置前端的跨域，也可以设置后端的跨域；后端更重要；

### 同源的定义

协议、端口号、域名完全相同

### 跨域方式

- CORS

  CORS是跨域的实现方式之一，比JSONP更强大。

- JSONP

  JSONP只支持GET请求，CORS支持所有类型的HTTP请求

  JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

- Node中间件代理 && Nginx反向代理

- 基于iframe的代理

### CORS

CORS正常的请求和相应

```http
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

```HTTP
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```

发送Cookie到服务器

```
CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：
Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。

后端：设置Access-Control-Allow-Credentials: true  
前端：
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = true;

* 如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。
```

CORS请求类别

AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。

- 简单请求

  ```
  必要条件：
      方法限制在GET、POST、HEAD
      HTTP头限制在五个，其中Content-Type只限于三个值
          application/x-www-form-urlencoded
          multipart/form-data
          text/plain
  
  Request：
  	对HTTP头增加Origin字段，后端得以判断
  
  Response：
      不在可允许范围内，返回正常HTTP请求；
      在可允许范围内， 会返回额外添加的头部信息：
          Content-Type: text/html; charset=utf-8
          Access-Control-Allow-Origin: http://api.bob.com  //必填 要么是原值，要么是*
          Access-Control-Allow-Credentials: true  		 //默认情况下，Cookie不包括在CORS请求之中；设置为ture则允许客户端发送Cookie到服务器
          Access-Control-Expose-Headers: FooBar			 //获取指定的请求头
  ```

- 预检请求

  在正式通信之前，增加一次HTTP查询请求；

  一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。

  ```
  必要条件：
  	方法为PUT或DELETE，或者Content-Type字段的类型是application/json。
  
  Request：
  	HTTP头中, 除Origin外, 增加两个特殊字段：
  		Access-Control-Request-Method						// 必填，为HTTP方法
  		Access-Control-Request-Headers						// 浏览器CORS请求会额外发送的头信息字段
  		
  Response：
  	检查发送的三个字段
  	若成功，则增加额外的HTTP头：
  		Access-Control-Allow-Origin: *					// 同上，value为原值或*
          Access-Control-Allow-Methods: GET, POST, PUT	// 必填，value为允许通过的方法
          Access-Control-Allow-Headers: ...				// 若前端设置了额外的头部信息Access-Control-Request-Headers, 则该字段必填
          Access-Control-Allow-Credentials: true			// 允许cookie
          Access-Control-Max-Age: 100000					// 预检有效期，期间内不需要发送预检请求
          
  ```

## 安全

### XSS

定义：Cross Site Script (跨站脚本攻击)， 为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

危害：攻击者可以通过注入恶意脚本获取用户的 Cookie 信息

分类

- 反射型

  ```
  将脚本注入到页面中，引诱其点击触发
  ```

- 存储型

  ```
  服务器端：将脚本注入到服务器端，每次服务器处理时触发
  ```

- DOM型

  ```
  客户端：修改DOM结构
  ```

防范

- CSP (Content Security Policy)：在meta中设置CSP额外保护层，指定有效域才可访问加载
- HTTP only：设置带有HTTP only属性的Cookie将禁止JS访问，只能通过HTTP形式访问
- 输入验证(表单验证)： 验证< >
- 输出验证(服务器返回内容验证): 

### CSRF

定义：Cross Site Request Forgery (跨站请求伪朝)；劫持用户Cookie，向服务器攻击

特点：攻击者只能给服务器发送请求，而无法窃取Cookie本身。

防御：

- 验证码
- 后端根据HTTP Referer字段来检查其请求源地址
- Token验证：在请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token

## Cookie

> 9.Cookie的一些安全设置

Cookie定义：服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上，主要用于

- 会话状态管理（用户状态）
- 个性化设置

Cookie类别：

每个 Cookie 都会有与之关联的域，这个域的范围一般通过 `donmain` 属性指定

- Session Cookie：无需指定Expired && Max-Age
- Permanate Cookie：可以指定Expired && Max-Age

## Token

> 8.Token的登录鉴权是怎么做的

## Axios

> Axios封装了什么
>
>  axios的拦截器知道吗？拦截器有什么用？

## 基础语法类

- ES6中对Object类做了什么优化

  ```
  1.对象使用方面
  	var
  	let
  	const
  解构
  	const obj = {name,age}
  函数
  	const module_ = {
  		fn(){}
  	}
  2. 新增方法
  Object.is
  Object.assign
  Object.getOwnPropertyDescriptor
  Object.keys / values /entries
  ```

- 有了解过JS最新的语法吗，使用这些语法需要考虑什么

- 关于typescript

  ```
  首先ts，本身是基于js的，不存在说什么取代的问题。
  ts编译后的代码依旧是js，只是js的超集
  当js本身加入了类型检测，ts，flow都会退出历史舞台
  ```

- 箭头函数和普通函数的区别

- css有哪些长度单位

- 防抖和节流是什么
- 事件循环，浏览器事件循环和node的区别
- 讲解Flex的参数
- 怎么画0.5px × 讲的不好
- script标签 defer async

- 17.事件机制

  18.事件循环

  19.闭包的作用，自执行函数是闭包吗

  20.Keep-alive组件

- 讲一下CSS3的动画

- ES6的新特性你知道哪些？

- 异步编程解决方案Promise，详细说一下？

- Promise为什么可以在状态变化之后再获取结果？

- css 中 bfc了解吗 说一下是什么 有什么应用场景

- 事件循环机制说一下

- 节流函数知道吗？封装一个节流函数。

- js的事件模型哪几个阶段都了解吗？那是先捕获阶段还是先冒泡阶段？

- 了解浏览器的缓存策略吗？

- 箭头函数的原型函数是什么（箭头函数没有原型对象）

- webpack怎么学的？如果一个项目有成百上千个入口文件怎么办？
  Promise.all和Promise.race说一下，应用场景有哪些？

- 刚刚那个arguements再介绍一下

- Promise.all方法有用过吗？实现一下？手写了一个，然后有一点细节问题面试官让我改一下，参数里有不是promise情况怎么做？那想要返回的结果和入参一一对应该怎么做？

- 看代码说答案，关于this指向的，我说错了，甚至我还不知道为什么 看来还需要补补

```
const length = 10
const fn = function () {
    return this.length + 1
}
const obj = {
    length: 5,
    test: function () {
        return fn()
    }

}
//下面输出是什么？
console.log(obj.test())
```

```
var a = function(){this.b = 3}
var c = new a()
a.prototype.b = 9
var b = 7
a()

//分别输出什么？为什么？
console.log(b)
console.log(c.b)
上面这段代码放到一个立即执行函数里面执行，会有什么不同吗？为什么？（这里脑子有点被绕晕了，其实牢记直接以函数形式被调用的时候，函数的this默认指向window就可以了。我怎么这么菜啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊）
```

```
问下面这一段放在浏览器执行，会怎么样？我一开始在分析，然后分析着他就问浏览器界面会卡死吗？我也不清楚标准答案，我说宏任务队列会不断更新，如果页面已经渲染完了就不会让浏览器卡死。
const fn = ()=>{
    setTimeout(()=>{fn();},0)
}
fn();

紧接着他又改了改：那下面这个会怎么样呢？我说这个会不断更新微任务队列可能导致界面卡死，他说当前这一个执行栈会怎么样，我回答可能永远不会停止所以界面卡死。

const fn = ()=>{
    Promise.resolve().then(()=>{fn();})
}
fn();
```



## 框架类

- react用的多吗
- 聊一下虚拟dom和diff算法

- 再展开一下diff的双向指针向内遍历

- react的官方hooks

- Vue2和Vue3的响应式对于数组而言有什么不同？

- Vue2有哪些钩子？网络请求应该放在哪里？如果是使用骨架屏或者加载动画的话，请求又应该放在哪里？

- react hooks 在if判断中使用会怎么样？当时也没想清楚 面试官又说那我们也换一个思路 刚刚你说你了解react源码 那对它的fiber架构有了解吗 我简单说了一下任务的优先级

- 反问那fiber是一个什么数据结构？我说是树结构 面试官说不对 是链表结构 如果if语句去调hook 会将整个结构打断的，然后基于这个和面试官讨论了一小会。

- 为什么使用vuex，不用vuex可不可以，什么情况下用vuex比较好 × 中大型单页应用

- 介绍一下Vue-router的两种模式 × hash模式和history模式，之前没有用过

- v-for为什么要加key，不加key页面渲染会出现错误吗

## 项目类

- 自我介绍
- 项目是自己想的吗？
- 做项目学到了什么？
- 如果没有后端接口，前端怎么提前模拟数据请求？

- 聊一下项目中的难点
- 自己做项目的时候遇到的最有挑战的事情？
- 介绍剩下的项目

## 算法类

- 手撕算法
  判断链表是否有环，不能用本地IDE，自己定义数据结构

		我最后说了三种方法
		1、直接for暴力10001
		2、快慢指针
		3、哈希

- 最长递增子序列，动态规划，撕掉，但是我最后返回值写错了，dp数组没错

- 版本号排序

- 一个匹配模式和一个字符串，检验字符串是否符合匹配模式。比如模式abba，字符串dog cat cat dog就返回true；但是如果是dog dog dog dog这种就返回false。（用哈希表其实很快就能解决，只是最后需要考虑不同的key不能有相同的value，处理后一种情况。这里我像个猪逼，一直没想到最后一种边界情况的处理方式）

- 全排列 × 回溯就可以做，力扣46题改一下就行

## 工程与性能类

- 怎么接触到的前端呢
- 学习方式有哪一些？视频 博客 书籍 项目中运用
- 实习主要做了些什么？ 主要做哪些项目？tob的也有toc的也有，然后根据实习里的组件库项目讨论了一下jest测试用例 覆盖率等等

- loader和plugin的区别，用过plugin吗
- 有听过deno（？）吗 (没有
- 吸顶的效果是怎么实现的？如果需要你原生实现呢？
- 怎么从前端的角度减少首页的白屏时间？
- 如果减少请求的数据之后，首页渲染时间还是不达标？应该怎么办？
- 怎样加快网页二次渲染速度？（除了缓存、懒加载之外的方法）
- 从你自己的角度看，TypeScript有用吗？
- 合作开发项目的时候遇到过项目成员意见有冲突的情况吗？怎么解决的？
- 想从实习里面学到什么？倾向于业务还是工程化？
- 如果开发过程中遇到了一个问题？你倾向于使用什么方式解决？
- 用全局组件可以减少代码体积，但是有什么危害 × 危害这里回答不上来了
- 1.自我介绍
- 2.实习有什么收获
- 3.实习的过程中，开发的过程是怎么样的，前后端怎么沟通，然后聊了一点有关接口文档的东西

- 4.怎么解决多端不兼容的问题，那Uni-app一套代码可以编译成多端的小程序有什么不好的地方 × 不知道有什么缺点

  5.团队怎么去做代码维护和校验的

  6.怎么用git lab进行团队的协作

  7.Git revert 和git reset有什么区别 × git reset是将HEAD移向过去，git revert是将HEAD移向未