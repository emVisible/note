# 网络类

<img src="C:\Users\16193\AppData\Roaming\Typora\typora-user-images\image-20230710143828900.png" alt="image-20230710143828900" style="zoom:67%;" />

<img src="C:\Users\16193\AppData\Roaming\Typora\typora-user-images\image-20230710144031221.png" alt="image-20230710144031221" style="zoom:67%;" />

## 三次握手与四次挥手

- 三次握手

  ```
  SYN
  ACK SYN
  ACK
  ```



- 四次挥手为什么是四次，三次不行吗？

  ```
  ·报文段1：
  	A FIN。
  	主动关闭方向被动关闭方发送结束报文段。
  ·报文段2：
  	B ACK
  	被动关闭方发送结束报文段确认，此时主动关闭方数据已经传输完毕。
  ·报文段3：
  	B FIN ACK
  	被动关闭方数据也发送完毕，发送结束报文段。
  ·报文段4：
  	A ACK
  	closed
  	主动关闭方对结束报文段进行确认。
  
  ACK用来应答，SYN用来同步
  关键在于第二段挥手。Server段只发送ACK，意思是我收到了结束请求。而服务端是可以一下子发送FIN和ACK的，但是第二段挥手没有一次性发完是因为，我现在身上还有活，等我忙完了我再发FIN和ACK。类比聚餐，朋友打来电话要你现在来，而自己还有些活没忙完，这时候你会说“等我忙完了再过去”是一个道理。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。
  ```

## HTTP基础

> http请求的方法，说说put，这样做为了什么规范
>
> https和http ？讲了混合加密过程和ssl证书数字签名等等。





## HTTP缓存

缓存本身是计算机的内存，同时开辟硬盘作为数据存储区域，通过这块区域来缓存信息

HTTP缓存=浏览器缓存+服务器缓存

### 前端缓存

Cookie，localStorage，SessionSotrage，IndexedDB

- Cookie：4KB、每次请求都会加在请求头里、非敏感信息、浏览器关闭消失
- localStorage：5MB、永久、同步、同源限制
- SessionSotage：5MB、会话、同步、同源限制
- IndexedDB：5-50MB、对象存储、异步请求、同源限制、并发限制

### 后端缓存

方式：HTTP主要通过请求和相应Header来控制缓存，缩短网络请求距离

优点：

- 节省流量
- 降低网络负荷
- 提高响应速度

分类(是否需要重新向服务器发送请求)

- 强缓存 (直接读取缓存，返回200)

  由header中的Pragma、Cache-Control、Expires控制

- 协商缓存 (重新发送请求，返回304)

  由header中的Etag和LastModified控制

*用户行为

- 新页面、前进、后退: 均有效

- F5: 仅对协商缓存有效

- ctrl+f5:均无效

### 问题

同一url的两个页面会共享localStorage和sessionStorage吗？ local共享、session不共享

如何设置禁用缓存？

```
服务端:
	设置Nginx && Apache的header——Cache-Control
客户端:
	浏览器 && devtool禁用
	meta标签设置禁用
		<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
		<meta http-equiv="Pragma" content="no-cache" />
		<meta http-equiv="Expires" content="0" />
```

## 跨域

> 跨域问题有遇到过吗？怎么解决的呢？实际项目和实习中遇到是怎么解决的？

跨域可以设置前端的跨域，也可以设置后端的跨域；后端更重要；

### 同源的定义

协议、端口号、域名完全相同

### 跨域方式

- CORS

  CORS是跨域的实现方式之一，比JSONP更强大。

- JSONP

  JSONP只支持GET请求，CORS支持所有类型的HTTP请求

  JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

- Node中间件代理 && Nginx反向代理

- 基于iframe的代理

### CORS

CORS正常的请求和相应

```http
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

```HTTP
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```

发送Cookie到服务器

```
CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：
Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。

后端：设置Access-Control-Allow-Credentials: true
前端：
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = true;

* 如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。
```

CORS请求类别

AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。

- 简单请求

  ```
  必要条件：
      方法限制在GET、POST、HEAD
      HTTP头限制在五个，其中Content-Type只限于三个值
          application/x-www-form-urlencoded
          multipart/form-data
          text/plain

  Request：
  	对HTTP头增加Origin字段，后端得以判断

  Response：
      不在可允许范围内，返回正常HTTP请求；
      在可允许范围内， 会返回额外添加的头部信息：
          Content-Type: text/html; charset=utf-8
          Access-Control-Allow-Origin: http://api.bob.com  //必填 要么是原值，要么是*
          Access-Control-Allow-Credentials: true  		 //默认情况下，Cookie不包括在CORS请求之中；设置为ture则允许客户端发送Cookie到服务器
          Access-Control-Expose-Headers: FooBar			 //获取指定的请求头
  ```

- 预检请求

  在正式通信之前，增加一次HTTP查询请求；

  一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。

  ```
  必要条件：
  	方法为PUT或DELETE，或者Content-Type字段的类型是application/json。
  
  Request：
  	HTTP头中, 除Origin外, 增加两个特殊字段：
  		Access-Control-Request-Method						// 必填，为HTTP方法
  		Access-Control-Request-Headers						// 浏览器CORS请求会额外发送的头信息字段
  
  Response：
  	检查发送的三个字段
  	若成功，则增加额外的HTTP头：
  		Access-Control-Allow-Origin: *					// 同上，value为原值或*
          Access-Control-Allow-Methods: GET, POST, PUT	// 必填，value为允许通过的方法
          Access-Control-Allow-Headers: ...				// 若前端设置了额外的头部信息Access-Control-Request-Headers, 则该字段必填
          Access-Control-Allow-Credentials: true			// 允许cookie
          Access-Control-Max-Age: 100000					// 预检有效期，期间内不需要发送预检请求
  
  ```

## 安全

### XSS

定义：Cross Site Script (跨站脚本攻击)， 为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

危害：攻击者可以通过注入恶意脚本获取用户的 Cookie 信息

分类

- 反射型

  ```
  将脚本注入到页面中，引诱其点击触发
  ```

- 存储型

  ```
  服务器端：将脚本注入到服务器端，每次服务器处理时触发
  ```

- DOM型

  ```
  客户端：修改DOM结构
  ```

防范

- CSP (Content Security Policy)：在meta中设置CSP额外保护层，指定有效域才可访问加载
- HTTP only：设置带有HTTP only属性的Cookie将禁止JS访问，只能通过HTTP形式访问
- 输入验证(表单验证)： 验证< >
- 输出验证(服务器返回内容验证):

### CSRF

定义：Cross Site Request Forgery (跨站请求伪朝)；劫持用户Cookie，向服务器攻击

特点：攻击者只能给服务器发送请求，而无法窃取Cookie本身。

防御：

- 验证码
- 后端根据HTTP Referer字段来检查其请求源地址
- Token验证：在请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token

## Cookie

> 9.Cookie的一些安全设置

Cookie定义：服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上，主要用于

- 会话状态管理（用户状态）
- 个性化设置

Cookie类别：

每个 Cookie 都会有与之关联的域，这个域的范围一般通过 `donmain` 属性指定

- Session Cookie：无需指定Expired && Max-Age
- Permanate Cookie：可以指定Expired && Max-Age

## Token

> 8.Token的登录鉴权是怎么做的

## Axios

> Axios封装了什么
>  axios的拦截器知道吗？拦截器有什么用？
原理
- 基于Promise进行XHR封装

基本使用
```js
  axios(config)
  axios.request(config)
  axios.create() // 多用
  axios.get/post/delete/head...
```

config
- HTTP相关
  - url
  - baseURL
  - method
  - params
  - headers
  - auth
- 数据相关
  - data
  - transformRequest
  - transformResponse
- ```js
  // 针对某个实例进行特定config配置
  instance.default.xxx
```

并发请求
``js
  可通过axios.spread()展开结果
  axios.all([
    Axios-instance,
    Axios-instance,
    Axios-instance
  ])

```

拦截器
拦截器基于Promise, 对应的需要返回Promise

- 请求拦截器
  - 使用场景:
    1.  请求时的体验优化: loading icon
    2.  对用户token验证
    3.  请求参数序列化
    4.  基于URL的版本控制(replace URI)
    5.  多次请求保持唯一

- 响应拦截器
  - 使用场景:
    1. 针对相应码分类处理



基本使用
插件: 请求重试(axios-retry) / 支持跨域(axios-jsonp)
```js
  // 未对拦截器进行函数封装
  // 1. 创建实例, 配置相关的config; 2. 设置请求拦截器和相应拦截器;
  const instance = axios.create({
    baseUrl: fromEnv,
    timeout: 3000
  })

  // 每次请求前验证当前是否有token, 若有则拿出并为header中设置为X-Token字段
  instance.interceptors.request.use(config=>{
    config.headers['X-Token'] = store.getters.token && store.getters.token ()
    return config
  }, error=>{
    console.error(error)
    return Promise.reject(error)
  })

  // 每次收到相应前判断状态码是否为20000, 若不是则返回Promise[reject]
  instance.interceptors.response.use(res=>{
    return res.code === 20000 ? res : Promise.reject("Error")
  }, error=>{
    console.error(error)
    return Promise.reject(error)
  })
  export default isntance
```

```js
  // 添加拓展
  async function requestInterceptor(){
    const res = await instance.interceptors.request.use(config=>{
        config.headers['X-Token'] = store.getters.token && store.getters.token ()
        return config
      }, error=>{
        console.error(error)
        return Promise.reject(error)
      })
      }

    let data = res.data || undefined
    // 业务代码

    return data
```

 




# JavaScript

## 模块

模块系统为了兼容性，大量运用ES5作用域语法，即IIFE

### 模块标准的分类

- 第三方标准（ES5）

  - CMD (Common Module Definition, 普通模块定义)

    对应CommonJS实现，对标服务器环境

  - AMD (Asynchronous Module Definition, 异步模块定义)

    对标受延迟限制的客户端环境

  - UMD(Universal Module Definition, 通用模块定义)

- 原生标准（ES6+）

  - ESM（ECMAScript Module）

    浏览器环境



### CMD模块

特点：

- 服务器端环境

- 同步加载
- 支持动态依赖加载（类似python
- 加载缓存（初次加载后生成缓存
- 全局单例
- 依赖全局对象require、export、module
- 不可直接在浏览器中使用；如需在浏览器中使用，需要提前打包



### AMD模块

特点

- 受延迟限制的客户端环境（并不专门针对浏览器环境

- 函数包装模块定义
- 可以用字符串指定依赖
- 支持require、exports对象
- 支持动态依赖



### UMD模块

目的：统一CJS和AMD系统，实现两个生态共存

流程：

1. 启动时检测模块系统
2. 对需要的模块系统进行配置
3. 将逻辑封装在IIFE中



### ESM模块系统

模块标签：

- 给script添加type=module，浏览器将会把该脚本当为模块执行；

- 执行顺序同defer相同——可以类比为宏任务，立即下载文件，文档解析完毕后执行；

  单设置defer的效果：原始script优先加载和执行->defer按顺序加载->等待文档解析完毕后执行

  单设置async的效果：原始script优先加载和执行->async无序加载->不等待文档解析，直接执行

- 模块层面上，同步加载执行

- 模块加载为单例——多次加载只视为一次

  *设置type为module后，import只能在外部的js文件中使用，不能在内联script中使用

  *在script上设置nomodule属性以解决浏览器兼容问题

模块加载

整个流程类似于AMD加载

1. 浏览器异步加载整个依赖图
2. 确定入口模块->确定依赖->请求资源
3. 递归加载子依赖

特点：

- 支持循环依赖（所有模块都支持） / 单例加载 / 子依赖 /
- 默认为严格模式
- 顶级this为undefined，var声明不会到window对象中
- 异步加载 && 异步执行
- 独立作用域

导入与导出

导出：默认导出 && 具名导出 && 别名导出 / 转移导出

导入： 默认导入 && 成员导入 && 别名导入 && 批量导入&&直接导入

## 事件循环

浏览器->环境->子环境

在浏览器中每打开一个页面，就会分配一个它自己的环境。这样，每个页面都有自己的内存、事件循环、DOM等



## WebWorker

创造独立的二级子环境，不能与DOM等依赖单线程交互的API操作，但可以与父环境交换信息

特点

- 底层以实际线程执行
- 并行
- 可用SharedArrayBuffer在多个环境共享信息
- 没有window的概念，全局对象为WokerGlobalScope，以self关键字暴露
- 创建性能开销大
- 内存占用大

分类

- 专用型：只能被创建它的页面使用



- 共享型

  - 可以被多个不同的上下文使用，包括不同的页面
  - 与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送消息或从中接收消息。

- 服务型：拦截、重定向和修改页面发出的请求

# Ts

基本概念

- 泛型标识符: 可以是任何标识符, 大部分为约定俗称, 以通俗易懂为主
  - T(泛指类型Type)； U V泛指第二个第三个类型参数
  - K && V(泛指对象中的key和value)
  - E 一般为数组元素的类型

使用场景

- 泛型约束(Generic  Constrainsts)

例子

```
// 函数的参数和返回值均为传递的泛型类型
function same<T>(param:T=stirng):T{
	...
}

// 传递的泛型限制内部函数的对象类型
interface keyValue<K, V>{
	key:K,
	value:V
}


```

- ES6中对Object类做了什么优化

  ```
  1.对象使用方面
  	var
  	let
  	const
  解构
  	const obj = {name,age}
  函数
  	const module_ = {
  		fn(){}
  	}
  2. 新增方法
  Object.is
  Object.assign
  Object.getOwnPropertyDescriptor
  Object.keys / values /entries
  ```

- 有了解过JS最新的语法吗，使用这些语法需要考虑什么

- 关于typescript

  ```
  首先ts，本身是基于js的，不存在说什么取代的问题。
  ts编译后的代码依旧是js，只是js的超集
  当js本身加入了类型检测，ts，flow都会退出历史舞台
  ```

- 箭头函数和普通函数的区别

- css有哪些长度单位

- 防抖和节流是什么
- 事件循环，浏览器事件循环和node的区别
- 讲解Flex的参数
- 怎么画0.5px × 讲的不好
- script标签 defer async

- 17.事件机制

  18.事件循环

  19.闭包的作用，自执行函数是闭包吗

  20.Keep-alive组件

- 讲一下CSS3的动画

- ES6的新特性你知道哪些？

- 异步编程解决方案Promise，详细说一下？

- Promise为什么可以在状态变化之后再获取结果？

- css 中 bfc了解吗 说一下是什么 有什么应用场景

- 事件循环机制说一下

- 节流函数知道吗？封装一个节流函数。

- js的事件模型哪几个阶段都了解吗？那是先捕获阶段还是先冒泡阶段？

- 了解浏览器的缓存策略吗？

- 箭头函数的原型函数是什么（箭头函数没有原型对象）

- webpack怎么学的？如果一个项目有成百上千个入口文件怎么办？
  Promise.all和Promise.race说一下，应用场景有哪些？

- 刚刚那个arguements再介绍一下

- Promise.all方法有用过吗？实现一下？手写了一个，然后有一点细节问题面试官让我改一下，参数里有不是promise情况怎么做？那想要返回的结果和入参一一对应该怎么做？

- 看代码说答案，关于this指向的，我说错了，甚至我还不知道为什么 看来还需要补补

```
const length = 10
const fn = function () {
    return this.length + 1
}
const obj = {
    length: 5,
    test: function () {
        return fn()
    }

}
//下面输出是什么？
console.log(obj.test())
```

```
var a = function(){this.b = 3}
var c = new a()
a.prototype.b = 9
var b = 7
a()

//分别输出什么？为什么？
console.log(b)
console.log(c.b)
上面这段代码放到一个立即执行函数里面执行，会有什么不同吗？为什么？（这里脑子有点被绕晕了，其实牢记直接以函数形式被调用的时候，函数的this默认指向window就可以了。我怎么这么菜啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊）
```

```
问下面这一段放在浏览器执行，会怎么样？我一开始在分析，然后分析着他就问浏览器界面会卡死吗？我也不清楚标准答案，我说宏任务队列会不断更新，如果页面已经渲染完了就不会让浏览器卡死。
const fn = ()=>{
    setTimeout(()=>{fn();},0)
}
fn();

紧接着他又改了改：那下面这个会怎么样呢？我说这个会不断更新微任务队列可能导致界面卡死，他说当前这一个执行栈会怎么样，我回答可能永远不会停止所以界面卡死。

const fn = ()=>{
    Promise.resolve().then(()=>{fn();})
}
fn();
```



## 框架类

- react用的多吗
- 聊一下虚拟dom和diff算法

- 再展开一下diff的双向指针向内遍历

- react的官方hooks

- Vue2和Vue3的响应式对于数组而言有什么不同？

- Vue2有哪些钩子？网络请求应该放在哪里？如果是使用骨架屏或者加载动画的话，请求又应该放在哪里？

- react hooks 在if判断中使用会怎么样？当时也没想清楚 面试官又说那我们也换一个思路 刚刚你说你了解react源码 那对它的fiber架构有了解吗 我简单说了一下任务的优先级

- 反问那fiber是一个什么数据结构？我说是树结构 面试官说不对 是链表结构 如果if语句去调hook 会将整个结构打断的，然后基于这个和面试官讨论了一小会。

- 为什么使用vuex，不用vuex可不可以，什么情况下用vuex比较好 × 中大型单页应用

- 介绍一下Vue-router的两种模式 × hash模式和history模式，之前没有用过

- v-for为什么要加key，不加key页面渲染会出现错误吗

## 项目类

- 自我介绍
- 项目是自己想的吗？
- 做项目学到了什么？
- 如果没有后端接口，前端怎么提前模拟数据请求？

- 聊一下项目中的难点
- 自己做项目的时候遇到的最有挑战的事情？
- 介绍剩下的项目

## 算法类

- 手撕算法
  判断链表是否有环，不能用本地IDE，自己定义数据结构

		我最后说了三种方法
		1、直接for暴力10001
		2、快慢指针
		3、哈希

- 最长递增子序列，动态规划，撕掉，但是我最后返回值写错了，dp数组没错

- 版本号排序

- 一个匹配模式和一个字符串，检验字符串是否符合匹配模式。比如模式abba，字符串dog cat cat dog就返回true；但是如果是dog dog dog dog这种就返回false。（用哈希表其实很快就能解决，只是最后需要考虑不同的key不能有相同的value，处理后一种情况。这里我像个猪逼，一直没想到最后一种边界情况的处理方式）

- 全排列 × 回溯就可以做，力扣46题改一下就行

## 工程与性能类

- 怎么接触到的前端呢
- 学习方式有哪一些？视频 博客 书籍 项目中运用
- 实习主要做了些什么？ 主要做哪些项目？tob的也有toc的也有，然后根据实习里的组件库项目讨论了一下jest测试用例 覆盖率等等

- loader和plugin的区别，用过plugin吗
- 有听过deno（？）吗 (没有
- 吸顶的效果是怎么实现的？如果需要你原生实现呢？
- 怎么从前端的角度减少首页的白屏时间？
- 如果减少请求的数据之后，首页渲染时间还是不达标？应该怎么办？
- 怎样加快网页二次渲染速度？（除了缓存、懒加载之外的方法）
- 从你自己的角度看，TypeScript有用吗？
- 合作开发项目的时候遇到过项目成员意见有冲突的情况吗？怎么解决的？
- 想从实习里面学到什么？倾向于业务还是工程化？
- 如果开发过程中遇到了一个问题？你倾向于使用什么方式解决？
- 用全局组件可以减少代码体积，但是有什么危害 × 危害这里回答不上来了
- 1.自我介绍
- 2.实习有什么收获
- 3.实习的过程中，开发的过程是怎么样的，前后端怎么沟通，然后聊了一点有关接口文档的东西

- 4.怎么解决多端不兼容的问题，那Uni-app一套代码可以编译成多端的小程序有什么不好的地方 × 不知道有什么缺点

  5.团队怎么去做代码维护和校验的

  6.怎么用git lab进行团队的协作

  7.Git revert 和git reset有什么区别 × git reset是将HEAD移向过去，git revert是将HEAD移向未