# 计组
内存的分类
- 代码段 (codesegment / textsegment)
- 数据段 (datasegment)
- bss段 (bsssegment)
- rodata段
- 栈
- 堆

# 计网

<img src="C:\Users\16193\AppData\Roaming\Typora\typora-user-images\image-20230710143828900.png" alt="image-20230710143828900" style="zoom:67%;" />

<img src="C:\Users\16193\AppData\Roaming\Typora\typora-user-images\image-20230710144031221.png" alt="image-20230710144031221" style="zoom:67%;" />

## 三次握手与四次挥手

- 三次握手

  ```
  SYN
  ACK SYN
  ACK
  ```



- 四次挥手为什么是四次，三次不行吗？

  ```
  ·报文段1：
  	A FIN。
  	主动关闭方向被动关闭方发送结束报文段。
  ·报文段2：
  	B ACK
  	被动关闭方发送结束报文段确认，此时主动关闭方数据已经传输完毕。
  ·报文段3：
  	B FIN ACK
  	被动关闭方数据也发送完毕，发送结束报文段。
  ·报文段4：
  	A ACK
  	closed
  	主动关闭方对结束报文段进行确认。
  
  ACK用来应答，SYN用来同步
  关键在于第二段挥手。Server段只发送ACK，意思是我收到了结束请求。而服务端是可以一下子发送FIN和ACK的，但是第二段挥手没有一次性发完是因为，我现在身上还有活，等我忙完了我再发FIN和ACK。类比聚餐，朋友打来电话要你现在来，而自己还有些活没忙完，这时候你会说“等我忙完了再过去”是一个道理。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。
  ```

## HTTP基础

> http请求的方法，说说put，这样做为了什么规范
>
> https和http ？讲了混合加密过程和ssl证书数字签名等等。





## HTTP缓存

> 了解浏览器的缓存策略吗？

缓存本身是计算机的内存，同时开辟硬盘作为数据存储区域，通过这块区域来缓存信息

HTTP缓存=浏览器缓存+服务器缓存

### 前端缓存

Cookie，localStorage，SessionSotrage，IndexedDB

- Cookie：4KB、每次请求都会加在请求头里、非敏感信息、浏览器关闭消失
- localStorage：5MB、永久、同步、同源限制
- SessionSotage：5MB、会话、同步、同源限制
- IndexedDB：5-50MB、对象存储、异步请求、同源限制、并发限制

### 后端缓存

方式：HTTP主要通过请求和相应Header来控制缓存，缩短网络请求距离

优点：

- 节省流量
- 降低网络负荷
- 提高响应速度

分类(是否需要重新向服务器发送请求)

- 强缓存 (直接读取缓存，返回200)

  由header中的Pragma、Cache-Control、Expires控制

- 协商缓存 (重新发送请求，返回304)

  由header中的Etag和LastModified控制

*用户行为

- 新页面、前进、后退: 均有效

- F5: 仅对协商缓存有效

- ctrl+f5:均无效

### 问题

同一url的两个页面会共享localStorage和sessionStorage吗？ local共享、session不共享

如何设置禁用缓存？

```
服务端:
	设置Nginx && Apache的header——Cache-Control
客户端:
	浏览器 && devtool禁用
	meta标签设置禁用
		<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
		<meta http-equiv="Pragma" content="no-cache" />
		<meta http-equiv="Expires" content="0" />
```

## 跨域

> 跨域问题有遇到过吗？怎么解决的呢？实际项目和实习中遇到是怎么解决的？

跨域可以设置前端的跨域，也可以设置后端的跨域；后端更重要；

		JSONP 动态创建script标签
		CORS 服务端设置请求头
		websocket
		代理服务器

### 同源的定义

协议、端口号、域名完全相同

### 跨域方式

- CORS

  CORS是跨域的实现方式之一，比JSONP更强大。

- JSONP

  JSONP只支持GET请求，CORS支持所有类型的HTTP请求

  JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

- Node中间件代理 && Nginx反向代理

- 基于iframe的代理

### CORS

CORS正常的请求和相应

```http
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

```HTTP
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```

发送Cookie到服务器

```
CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：
Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。

后端：设置Access-Control-Allow-Credentials: true
前端：
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = true;

* 如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。
```

CORS请求类别

AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。

- 简单请求

  ```
  必要条件：
      方法限制在GET、POST、HEAD
      HTTP头限制在五个，其中Content-Type只限于三个值
          application/x-www-form-urlencoded
          multipart/form-data
          text/plain

  Request：
  	对HTTP头增加Origin字段，后端得以判断

  Response：
      不在可允许范围内，返回正常HTTP请求；
      在可允许范围内， 会返回额外添加的头部信息：
          Content-Type: text/html; charset=utf-8
          Access-Control-Allow-Origin: http://api.bob.com  //必填 要么是原值，要么是*
          Access-Control-Allow-Credentials: true  		 //默认情况下，Cookie不包括在CORS请求之中；设置为ture则允许客户端发送Cookie到服务器
          Access-Control-Expose-Headers: FooBar			 //获取指定的请求头
  ```

- 预检请求

  在正式通信之前，增加一次HTTP查询请求；

  一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。

  ```
  必要条件：
  	方法为PUT或DELETE，或者Content-Type字段的类型是application/json。
  
  Request：
  	HTTP头中, 除Origin外, 增加两个特殊字段：
  		Access-Control-Request-Method						// 必填，为HTTP方法
  		Access-Control-Request-Headers						// 浏览器CORS请求会额外发送的头信息字段
  
  Response：
  	检查发送的三个字段
  	若成功，则增加额外的HTTP头：
  		Access-Control-Allow-Origin: *					// 同上，value为原值或*
          Access-Control-Allow-Methods: GET, POST, PUT	// 必填，value为允许通过的方法
          Access-Control-Allow-Headers: ...				// 若前端设置了额外的头部信息Access-Control-Request-Headers, 则该字段必填
          Access-Control-Allow-Credentials: true			// 允许cookie
          Access-Control-Max-Age: 100000					// 预检有效期，期间内不需要发送预检请求
  
  ```

## 安全

### XSS

定义：Cross Site Script (跨站脚本攻击)， 为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

危害：攻击者可以通过注入恶意脚本获取用户的 Cookie 信息

分类

- 反射型

  ```
  将脚本注入到页面中，引诱其点击触发
  ```

- 存储型

  ```
  服务器端：将脚本注入到服务器端，每次服务器处理时触发
  ```

- DOM型

  ```
  客户端：修改DOM结构
  ```

防范

- CSP (Content Security Policy)：在meta中设置CSP额外保护层，指定有效域才可访问加载
- HTTP only：设置带有HTTP only属性的Cookie将禁止JS访问，只能通过HTTP形式访问
- 输入验证(表单验证)： 验证< >
- 输出验证(服务器返回内容验证):

### CSRF

定义：Cross Site Request Forgery (跨站请求伪朝)；劫持用户Cookie，向服务器攻击

特点：攻击者只能给服务器发送请求，而无法窃取Cookie本身。

防御：

- 验证码
- 后端根据HTTP Referer字段来检查其请求源地址
- Token验证：在请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token

## Cookie

> 9.Cookie的一些安全设置

Cookie定义：服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上，主要用于

- 会话状态管理（用户状态）
- 个性化设置

Cookie类别：

每个 Cookie 都会有与之关联的域，这个域的范围一般通过 `donmain` 属性指定

- Session Cookie：无需指定Expired && Max-Age
- Permanate Cookie：可以指定Expired && Max-Age

## Token

> 8.Token的登录鉴权是怎么做的

## Axios

> Axios封装了什么
>  axios的拦截器知道吗？拦截器有什么用？
原理
- 基于Promise进行XHR封装

基本使用
```js
  axios(config)
  axios.request(config)
  axios.create() // 多用
  axios.get/post/delete/head...
```

config
- HTTP相关
  - url
  - baseURL
  - method
  - params
  - headers
  - auth
- 数据相关
  - data
  - transformRequest
  - transformResponse
- ```js
  // 针对某个实例进行特定config配置
  instance.default.xxx
```

并发请求
``js
  可通过axios.spread()展开结果
  axios.all([
    Axios-instance,
    Axios-instance,
    Axios-instance
  ])

```

拦截器
拦截器基于Promise, 对应的需要返回Promise

- 请求拦截器
  - 使用场景:
    1.  请求时的体验优化: loading icon
    2.  对用户token验证
    3.  请求参数序列化
    4.  基于URL的版本控制(replace URI)
    5.  多次请求保持唯一

- 响应拦截器
  - 使用场景:
    1. 针对响应码分类处理



基本使用
插件: 请求重试(axios-retry) / 支持跨域(axios-jsonp)
```js
  // 未对拦截器进行函数封装
  // 1. 创建实例, 配置相关的config; 2. 设置请求拦截器和相应拦截器;
  const instance = axios.create({
    baseUrl: fromEnv,
    timeout: 3000
  })

  // 每次请求前验证当前是否有token, 若有则拿出并为header中设置为X-Token字段
  instance.interceptors.request.use(config=>{
    config.headers['X-Token'] = store.getters.token && store.getters.token ()
    return config
  }, error=>{
    console.error(error)
    return Promise.reject(error)
  })

  // 每次收到相应前判断状态码是否为20000, 若不是则返回Promise[reject]
  instance.interceptors.response.use(res=>{
    return res.code === 20000 ? res : Promise.reject("Error")
  }, error=>{
    console.error(error)
    return Promise.reject(error)
  })
  export default isntance
```

```js
  // 添加拓展
  async function requestInterceptor(){
    const res = await instance.interceptors.request.use(config=>{
        config.headers['X-Token'] = store.getters.token && store.getters.token ()
        return config
      }, error=>{
        console.error(error)
        return Promise.reject(error)
      })
      }

    let data = res.data || undefined
    // 业务代码
    return data
```



# 数据结构与算法

## 稳定 & 不稳定

- 不稳定：快选堆希
- 稳定：插冒归基

## 时间复杂度

- 归并 / 桶 / 堆（最好、最坏和平均情况下的时间复杂度都相同）

- 选泡插n方，快归堆n老

# JavaScript Engine & V8

> Chrome浏览器进程

- 1 主进程  Broswer
- 1 GPU进程 GPU 
- 1 网络进程 Network
- N 渲染进程 renderer
- N 插件进程 plugin

## repaint & reflow

重绘与重排-repaint & reflow

- repaint: 只改变元素外观，与DOM操作无关
- reflow: 改变元素DOM结构

## 页面性能指标

### LCP

网站初次载入速度，应该控制该值在**2.5 秒**以内

### FID

首次输入延迟时间，为了提供良好的用户体验，页面的 FID 应为**100 毫秒**或更短。



### CLS

累积布局偏移，为了提供良好的用户体验，页面的 CLS 应保持在 **0.1.** 或更少。

# HTML

> H5新特性

```

	语义化标签
	增强表单
	音视频标签
	地理定位
	拖放API
	SVG绘图
	canvas
	web workers
	web storage
	web socket
	querySelector / querySelectorAll
```



# CSS

长度单位

- 分为绝对长度单位和相对长度单位
- em rem px % vh vw；ch ex ...看文档



怎么画0.5px 

- box-shadow阴影实现
-  ::after定位伪类实现
-  transform 缩放实现
-  border-image: linear-gradient 边框线性渐变

## 权重

```
	!important 
	inline-style
	ID
	class
	property
	element
```



## bfc

> css 中 bfc了解吗 说一下是什么 有什么应用场景

## 顶吸效果

> 吸顶的效果是怎么实现的？如果需要你原生实现呢？

# JavaScript

## 基础

```
valueOf返回原始值，如没有原始值则返回本身
toString返回字符串表示 (模板字符串、字符串拼接时会自动调用toString)
    [] {}的valueOf值为本身
    [] {}的toString值为"" [Object, Object]

URL一般格式
	protocol//host:port/path?search_condition

计算精度
    const a = 0.1
    const b = 0.2
    const c = 0.3
    b - a == a // true
    c - b == a // false
        0.1和0.2在转换为二进制时存在无限循环。观察可以看到实质上都是1100的无限循环，而0.1是三个0，0.2是两个0，就会导致最后一位四舍五入进位丢失精度。
		0.1在计算机中二进制表示为0.0001 1001 1001 ...
		0.2在计算机中二进制表示为0.0011 0011 0011 ...


parseFloat
	~('109283lsakdjf') 会自动处理前n个数字输出
	~('0xA') === 0     字符串，同上
	~('1214.213.1.41') 只解析第一个正确的浮点数格式 //1214.213
	~('000930424.241') 自动删除最前方的0 // 930424.241

isNaN
    isNaN(NaN) // true
    isNaN('...') // true
    isNaN('10') //false
    


数组
	数组创建可以直接一连串逗号 [,,,,,]，几个逗号长度为几
	
正则
	[0-9-]和[0-9\-]是一样的，都会匹配到-
	
BOM
	location.host  			如果是80端口，默认不显示；其它的均显示host:port
	location.hostname		只显示host
	location.pathname		返回当前页面路径和文件名
```



## 箭头函数

> 箭头函数的原型函数是什么（箭头函数没有原型对象）

- arguments
- this
  - arrow -> context this
- prototype -> new Xxx()
  - arrow function没有prototype，自然不能new



## ES6

>ES6的新特性你知道哪些？

## Promise

>- 异步编程解决方案Promise，详细说一下？
>- Promise为什么可以在状态变化之后再获取结果？
>- Promise.all和Promise.race说一下，应用场景有哪些？
>- Promise.all方法有用过吗？实现一下？手写了一个，然后有一点细节问题面试官让我改一下，参数里有不是promise情况怎么做？那想要返回的结果和入参一一对应该怎么做？



## 闭包

>19.闭包的作用，自执行函数是闭包吗

## this

> 只跟调用位置有关



## 深拷贝

> 来，写一个



## 模块

模块系统为了兼容性，大量运用ES5作用域语法，即IIFE

### 模块标准的分类

- 第三方标准（ES5）

  - CMD (Common Module Definition, 普通模块定义)

    对应CommonJS实现，对标服务器环境

  - AMD (Asynchronous Module Definition, 异步模块定义)

    对标受延迟限制的客户端环境

  - UMD(Universal Module Definition, 通用模块定义)

- 原生标准（ES6+）

  - ESM（ECMAScript Module）

    浏览器环境



### CMD模块

特点：

- 服务器端环境

- 同步加载
- 支持动态依赖加载（类似python
- 加载缓存（初次加载后生成缓存
- 全局单例
- 依赖全局对象require、export、module
- 不可直接在浏览器中使用；如需在浏览器中使用，需要提前打包



### AMD模块

特点

- 受延迟限制的客户端环境（并不专门针对浏览器环境

- 函数包装模块定义
- 可以用字符串指定依赖
- 支持require、exports对象
- 支持动态依赖



### UMD模块

目的：统一CJS和AMD系统，实现两个生态共存

流程：

1. 启动时检测模块系统
2. 对需要的模块系统进行配置
3. 将逻辑封装在IIFE中



### ESM模块系统

模块标签：

- 给script添加type=module，浏览器将会把该脚本当为模块执行；

- 执行顺序同defer相同——可以类比为宏任务，立即下载文件，文档解析完毕后执行；

  单设置defer的效果：原始script优先加载和执行->defer按顺序加载->等待文档解析完毕后执行

  单设置async的效果：原始script优先加载和执行->async无序加载->不等待文档解析，直接执行

- 模块层面上，同步加载执行

- 模块加载为单例——多次加载只视为一次

  *设置type为module后，import只能在外部的js文件中使用，不能在内联script中使用

  *在script上设置nomodule属性以解决浏览器兼容问题

模块加载

整个流程类似于AMD加载

1. 浏览器异步加载整个依赖图
2. 确定入口模块->确定依赖->请求资源
3. 递归加载子依赖

特点：

- 支持循环依赖（所有模块都支持） / 单例加载 / 子依赖 /
- 默认为严格模式
- 顶级this为undefined，var声明不会到window对象中
- 异步加载 && 异步执行
- 独立作用域

导入与导出

导出：默认导出 && 具名导出 && 别名导出 / 转移导出

导入： 默认导入 && 成员导入 && 别名导入 && 批量导入&&直接导入

##  事件模型

> js的事件模型哪几个阶段都了解吗？那是先捕获阶段还是先冒泡阶段？

阶段:

- 捕获
- 冒泡



## 宏任务与微任务

> 说一说宏任务和微任务对浏览器的阻塞关系

```
microtask
		promise.[then/catch/finally]
		MutationObserver
		
macrotask
    setTimeout / setInterval
    MessageChannel I/O
    requestIdleCallback 与macrotask性质相同
    requestAnimationFrame 
        请求动画帧，用于动画。
        替代定时器匹配设备刷新率，解决了定时器做动画时间间隔不稳定-不流畅的问题
```



## 事件与事件循环



类型

- 通用事件循环

  ```
  事件循环是一种并发模型，本质是一个死循环
  
  事件可以有很多种，比如文件读写事件、信号事件、超时事件、网络 I/O 事件等
  
  以libuv IO事件件库为例，通过fileno文件描述符来指定资源，对其注册可读和可写事件，通过run执行事件队列
  ```

- 浏览器事件循环

  ```
  浏览器->环境->子环境
  
  在浏览器中每打开一个页面，就会分配一个它自己的环境。这样，每个页面都有自己的内存、事件循环、DOM等
  ```

- Node事件循环

  ```
  Node中借助libuv的uv_async_t，实现watchdog对timer的管控机制，本质上是IO的操作，具体内容交给kernel处理
  
  Node主事件循环的每一个tick，都拥有内部的循环和对应watchdog的解析
  
  主事件循环确保内部循环得以使其生命周期正常运转，会经常判断is_stopping
  
  内循环通过uv_run，按顺序执行具体的代码：
  	1. timers：timeout hook
  	2. pending IO：少部分情况下，需要延迟IO，在下次tick开始时调用
  	3. 空转事件：若存在空转，直接continue；不等待IO；————————setImmediate()的机制：通过空转事件使其在tick中强行不等待IO
  	4. 准备事件：preprocess
  	5. poll 事件：大多数情况下，I/O 回调都会在poll IO后立即调用
  	6. 复查事件：postprocess
  	7. 结束：close hook
  
  时序相关：
  	timeout & interval
  	immediate
  	nextTick 其任务队列由node管理，通过固定位置设置实现；微任务队列由v8管理
  ```



## 防抖与节流

> 核心是限制请求频率

防抖(**debounce**)--一段时间内只执行一次

- 机制：定时器-辞旧迎新

  ```js
  function debounce(delay){
      let timer;
      return function(){
  		clearTimeout(timer)
          timer = setTimeout(()=>{
              // ajax request
          }, delay)
      }
  }
  const run = debounce(1000)
  
  const btn = document.getElementById("btn")
  btn.onclick = run
  ```

  

节流(**throttle**)-固定间隔时间执行

- 机制：定时器-通过类似于锁的机制来保证——固定的时间间隔内至少执行一次事件处理函数

```js
function throttle(delay){
    // 通过一个锁来实现节流机制
    let isOver = true;
    let timer;
    return function (){
        if (isOver){
            isOver = !isOver
            clearTimeout(timer)
            setTimeout(()=>{
                // code
                isOver = !isOver
            }, delay)
        }
    }
}

const run = throttle(1000)

const btn = document.getElementById("btn")
btn.onclick = run
```



## Map

Map与Object区别

- Map有序，Object无序
- 涉及大量增删 || 需要低内存占用，使用Map
- 涉及大量查找，使用Object



## WebWorker

创造独立的二级子环境，不能与DOM等依赖单线程交互的API操作，但可以与父环境交换信息

特点

- 底层以实际线程执行
- 并行
- 可用SharedArrayBuffer在多个环境共享信息
- 没有window的概念，全局对象为WokerGlobalScope，以self关键字暴露
- 创建性能开销大
- 内存占用大

分类

- 专用型：只能被创建它的页面使用

- 共享型

  - 可以被多个不同的上下文使用，包括不同的页面
  - 与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送消息或从中接收消息。

- 服务型：拦截、重定向和修改页面发出的请求



## 原生JS禁用

设置disabled attribute

# Ts

基本概念

- 泛型标识符: 可以是任何标识符, 大部分为约定俗称, 以通俗易懂为主
  - T(泛指类型Type)； U V泛指第二个第三个类型参数
  - K && V(泛指对象中的key和value)
  - E 一般为数组元素的类型

使用场景

- 泛型约束(Generic  Constrainsts)

例子

```
// 函数的参数和返回值均为传递的泛型类型
function same<T>(param:T=stirng):T{
	...
}

// 传递的泛型限制内部函数的对象类型
interface keyValue<K, V>{
	key:K,
	value:V
}


```

# React

聊一下虚拟dom和diff算法，再展开一下diff的双向指针向内遍历



react hooks 的if判断

 如果if语句去调hook 会将整个结构打断，对于批处理想要将对应的action和hook绑定是通过index来指定，如果被包在if等语句中，不能保证index++





# Vue

> 组件通信有哪些

	EventBus ($emit / $on)
	$parent / $children
	
	provide / inject
	props
	$emit
	ref 
	attrs / listeners
	vuex

Vue2和Vue3的区别



Vue2有哪些钩子？



为什么使用vuex，不用vuex可不可以，什么情况下用vuex比较好 × 中大型单页应用



介绍一下Vue-router的两种模式 × hash模式和history模式



v-for为什么要加key，不加key页面渲染会出现错误吗



# Webpack

> webpack怎么学的？如果一个项目有成百上千个入口文件怎么办？

> loader和plugin的区别，用过plugin吗

# 聊项目

> 做项目学到了什么？

> 聊一下项目中的难点 / 自己做项目的时候遇到的最有挑战的事情？



# 跨端开发

> Uni-app一套代码可以编译成多端的小程序有什么不好的地方

# 性能优化

怎么从前端的角度减少首页的白屏时间？

如果减少请求的数据之后，首页渲染时间还是不达标？应该怎么办？

怎样加快网页二次渲染速度？（除了缓存、懒加载之外的方法）

## 组件

> 用全局组件可以减少代码体积，但是有什么危害 



# Git

> Git revert 和git reset有什么区别
>
> ​	一般的使用时，如果已经push了，使用revert，如果没有，就是用reset

```
集中式-svn；分布式-git


git bisect
	搜索。使用二分法对有bug的提交定位，查找哪一次代码引入了错误

git stash
	保存。暂存当前分支下的更改，通过git stash pop还原

git merge
	合并分支。两个分支合并为新的提交，其会产生两个父节点

git rebase
	提交。将当前分支的提交，到目标分支；可能会改变hash值；容易使分支混乱，不知道从哪个分支拉取的代码

git fetch
	更新本地仓库。 将remote仓库更新的内容映射到本地，不会修改当前目录和分支

git revert
	revert 使用一个新的commit 来回滚你希望回滚的commit， reset 是直接HEAD 指向回退的commit

git reset
	执行的是 HEAD的指向的回退

git log

    git log -p查看文件变动信息

    git log -p -1234235678797654321....

    git log --oneline

    git log oneline --name-only文件发生变化

    git log oneline --name-status
    
git checkout
	恢复到上一次版本，撤回到上一次提交的内容：
	git checkout -- xxx.xxx 恢复上一个版本
	
git branch
    git branch --merged
    显示出来说明和master提交点相同
    说白了显示出来的是可以删除了的
    git branch --no -merged
    
	git branch -d xxx
	强制删除(没有合并但要删除)：
  	git branch -D xxx

git alias
	git命令别名
# ===================================================================

线上分支: master
本地分支: fix
修复bug:
	1. 切换到master目录，同fix分支合并实现bug的修改
		git checkout master => git merge fix => git push origin master
	2. 拉取fix最新代码到master上，
		(git checkout fix => git rebase master )=> (1操作)
```

---

## 一般流程

1. git pull
2. git add .
3. git commit -m 'xxx'
4. git remote add origin (_SSH_)
5. git branch -M main
6. git push origin main

# 手撕

手撕不动

```
2022小米1

给定包含红白蓝三种颜色，一共n个元素的数组，原地排序，使得相同颜色的元素相邻，按照红白蓝顺序排列。0为红，1为白，2为蓝。
	方法一：API 直接正序排序 arr.sort((a,b)=>a-b)
	方法二：不使用API
		function solution(arr:number[]){
			const red = []
			const white = []
			const blue = []
			for (const item of arr) {
				switch (item){
					case 0:
						red.push(item)
						break
					case 1:
						white.push(item)
						break
					case 2:
						blue.push(item)
						break
				}
			}
			return [...red, ...white, ...blue]
		}

2022小米2
	返回所有可能的子集
	给出: 1,2,3
	返回: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
	解法: 回溯
	funtion solution(nums){
		let res = [], arr = []
		function find(start){
			res.push([...arr])
			for (let i = start; i< nums.length ; i++ ){
				arr.push(nums[i])
				find(i+1)
				arr.pop()
			}
		}
		find(0)
		return res
	}
```



# 其它



> 开发的过程是怎么样的，前后端怎么沟通

> 想从实习里面学到什么？倾向于业务还是工程化？

>如果开发过程中遇到了一个问题？你倾向于使用什么方式解决？



