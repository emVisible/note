

# 编程相关技术

## 代码阅读

1. 激活

   ```
   主动思考：
   	· 注意到了什么？原因？
   	· 代码包括了哪些概念？
   	· 代码包括了哪些语法？
   	· 代码包括哪些领域概念？
   ```

2. 监测

   ```
   宏观：是否了解整体上实现的功能
   微观：是否每行都理解其作用
   ```

3. 确定重要性

   ```
   确定重要的部分：
   	· 为什么这里最重要？
   	· 微观作用是什么？
   	· 宏观作用是什么？
   ```

4. 推断

   ```
   根据变量名、context等推断代码意义
   	· 是否与领域概念有关？
   	· 涉及到了哪些编程概念？
   	· 提供了什么信息？
   	· 变量名之间哪些彼此相关联？
   	· 是否有需要context才能推断出的变量名？
   	· 其在库中的含义？
   ```

5. 视觉化

   ```
   通过一定方式呈现：
   	· 画图
   	· 画表格
   ```

6. 提问

   ```
   · 最核心的5个概念？
   · 采用哪些策略来确定核心概念？
   · 核心的计算机概念？（算法、数据结构）
   · 采用了什么决策实现？（设计模式、库、API）
     · 依赖于哪些假设
     · 有什么优点？
     · 有什么不足？
     · 是否有更好的决策？
   ```

7. 摘要

   - Aim: what function
   - Important
   - Area conception
   - Structure
   - Strategy

   



# Python 工具箱

---

- <img src="C:\Users\16193\AppData\Roaming\Typora\typora-user-images\image-20230222232334979.png" alt="image-20230222232334979" style="zoom:33%;" />量化投资概览

- 做的主要是webgis相关的，前端 leaflet+vue+ts，后段django+drf+geodjango+celery，db：mysql+pg+mongo，数据处理：numpy+pandas+xarray+geopandas等，wms wfs服务：geoserver/mapserver。

- config：

  - 更换镜像源

    ```
    pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/
    ```

- utils code

  ```
  列表推导式生成随机数：
  	list = [random.randint(1,1000) for i in range (1,1000)].sort()
  
  ```

---

- 工具库列表：

  - 底层包
    - 科学计算 && 数据分析：NumPy
  - 应用包
    - 计算：pandas

  

  - 数据可视化：Matplotlib
  - 计算：jupyter

----

- ## python基础知识

  ```
  type()
  isinstance()
  dir()
  
  OOP：
  	__slots__ 对动态语言进行一定的限制
  		class xxx():
  		__slots__ = ("","")
  	
  	@property 将方法变为属性
  	Mixin多继承
  	__init__
  	__str__
  	__repr__
  	__iter__
  	__getitem__
  	__getattr__
  	__call__
  	metaclass
  枚举
  异常捕获
  单元测试——TDD
  文档测试——
  文件操作
  	读写操作
  	目录操作
  	序列化操作
  进程线程
  	multiprocessing
  	threading / threadLocal
  	分布式进程
  正则
  ```
  
  

- ## ipython：

  ```
  1	!使用命令行命令
  	!vi xxx                                      通过vim创建python文件
  	
  	
  2	%run xxx                                      运行python文件
  	
  	
  3	%timeit xxx                                     显示运行时间
  	
  	
  4	%pdb 开启调试模式                                      ————当有一行代码出错时，回到上一行，进入调试模式
  		on 
  		off
  		p (var) 快速输出变量值
  		c 恢复到ipython
  		q 退出
  		a 当前函数参数
  		w 完整站栈追踪
  		l 当前行及其栈追踪
  		
  		
  5	%paste (粘贴)————运行粘贴代码
  	
  	
  6	%bookmark 指令 值                                        存储自己常用指令
  		-l
  		-d
  		-r 删除所有
  
  
  其它：
  	_：上n行的输出，是对结果的值引用
  	__*__?   命名空间搜索
  	命令行历史搜索：a + ↑
  ```

  - <img src="C:\Users\16193\AppData\Roaming\Typora\typora-user-images\image-20230222233700045.png" alt="image-20230222233700045" style="zoom: 50%;" />


- ## jupyter

  ```
  ~ notebook  网页版ipython
  ```
  
- ## numpy

  ```python
  可需求的满足：
  	量化交易：
  		跨国公司市值转换
  		求物品总金额
    
  核心使用：创建多维数组对象，进行数字运算。默认计算为小数级别。
  
  核心命令；
  import numpy as np
  	np.array() ————后可直接对数组进行四则运算。
  		arr_product = np.array(arr_product)
  		arr_num = np.array(arr_num)
          ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
  		sum = (arr_product * arr_num).sum()
          
   多维：
  	arr.size		=>: 2 * 2 * 3					=> 2 * 3
      arr.shape   	=>:(2,2,3)两页两行三列的三维数组	  => (2,3)两行三列的二维数组
  命令：
      ~.dtype 查看类型
      ~.size
      ~.shape
  	~.T 行列式转换
      ~.ndim 查看数组维数
  
      
      ~.zeros(n,dtype='')创建全0数组
      ~.ones(n,dtype='')创建全1数组
      ~.empty(n) 创建空数组，随机值
      
      ~.nrange(start,end,step)numpy版本的range()，步长可以是小数
      ~.linesapce(start_real_number,end_real_number,how_many_parts_of_this_array)
      
      ~.eye(n)线性代数单位矩阵
      
  （数组&&列表区别：数组的类型相同，大小固定）
  ```

  

---

# 前端工具箱

- electron——桌面端开发

  ```
  配置
  	主进程js文件——main
  	dev调试文件——dev
  
  {
    "name": "vite-electron",
    "private": true,
    "version": "0.0.0",
    "type": "module",
    "main": "electron/main.cjs",
    "scripts": {
      "dev": "concurrently \"vite\" \"electron .\"",
      "build": "vue-tsc && vite build",
      "preview": "vite preview"
    },
    "dependencies": {
      "vue": "^3.2.45"
    },
    "devDependencies": {
      "@vitejs/plugin-vue": "^4.0.0",
      "concurrently": "^7.6.0",
      "electron": "^23.1.1",
      "typescript": "^4.9.3",
      "vite": "^4.1.0",
      "vue-tsc": "^1.0.24"
    }
  }
  	
  ```

  ```
  初始化
  
  const {BrowserWindow, app} = require('electron')
  const createWindow = ()=>{
   const win =  new BrowserWindow({
      width:300,
      height:300,
      alwaysOnTop:true,
      // transparent:true
    })
    win.loadURL("http://localhost:5173/")
  }
  
  app.whenReady().then(()=>{
    createWindow()
  })
  ```

  ```
  网络安全——域名限制
  	参照MDN——https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP
    
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' ;script-src 'self' ">
  ```

  ```
  进程通信:
  
  	主进程：node环境
  	渲染进程：browser环境，指在html中调用的js
  	预加载脚本：安全考虑，开放部分node，可在主进程里修改为全部开放
  	默认情况下，preloader的命令同main和render隔离
  	
  	
  
  	命令：
  		ipcRenderer.send('',param)
  		ipcRenderer.on('',(arg,value)=>{})
  
  		ipcMain.on('',()=>{})
          
          contextBridge.exposeInMainWorld('',{})
  	
  	
  	
  	逻辑：
  		☆：
  			render同preload通信，结果在browser上：
  				render:win.webContents.send('',param)
  				preload:ipcRenderer.on('',callback)
  			
  			从render到main:
  				main:ipcMain.on('',(event,value)=>{})  //node服务器相应
  				preload:
  						外：context.exposeInMainWorld('',{func(callback){
  							内：ipcRender.send('',param) //preload向main发送
  							callback()   // 执行render回调传递数据
  						}})
  						
  				renderer:外：
                              document.addEventListener('DOMContentLoaded',()=>{
                                    const btn = document.querySelector('#btn')
                                    btn.addEventListener('click',()=>{
                                      内：window.access.func(()=>{  			//传入回调，连通browser数据
                                        btn.innerHTML = Number(btn.innerHTML) + 1
                                      })
                                    })
                                  })
  			main向web返回相应，收到通知：
  				
  	
  		main && preload：
  			主：  			ipcMain.on()
  			preload：		ipcRenderer.send()  
  		
  		主进程 && 渲染进程：
  			主：func(mainWindow)
  			渲染：win.webContents.on()
  		preload && 渲染进程：
  			preload：context.exposeInMainWorld('',{}) => ipcRenderer.on()
  			渲染：window.param.xxx() => mainWindow.webContents.send()
  	
  
  		preload同render——exposeInMainWorld()
  			1.直接接收。render设置send,preload设置on接收以及回调。render通过同main通信，获取mainWindow，设置win.webContent.send()发送
              preload:
                  contextBridge.exposeInMainWorld('variable_name',{
                      a:300
                  })
                  contextBridge.exposeInMainWorld('variable_name',{
                      method(){
                      ipcRenderer.send('msg_send')
                      }
                  })
              render:
                  window.variable_name
                  document.quryselctor("#btn").addEventListener('click',()=>{
                  window.variable_name.method()
                  })
  	
          preload 同 main——ipcRender() && ipcMain()
          	1.直接发送。preload里设置send，main里设置on。
          	2.通过renderDOM操作后发送。preload里进行contextBridge.exposeInMainWorld()暴露api，内容设置send()。
          	render通过window接收api，调用方法。main里设置on接收
       
              preload：
                  const { ipcRenderer } = require("electron")
                  ipcRenderer.send('Hello')
                  console.log('young \'s forever')
              main：
                  ipcMain.on('Hello', () => {
                      console.log('Hello yes')
                  })
          
                  
                  
  		main 同 render
              render:cmd模块导出，设置形参
              main：cmd模块导入，传参
              preload：设置ipcRenderer.on()接收render的ipcRenderer.send()，接收成功后在render Browser里输出
              预加载：设置回调
  		
  		
  		preload连通：
  			
  ```
  
  
  
  ```
  简易api：
  	main：		ipcMain.handle()
  	preload：	M)ipcRenderer.invoke()  R)contextExposedToMainWorld()
  	render：		window.api.func()
  大量使用回调
  ```
  
  ```
  通信隔离：
  
      const createWindow = ()=>{
        const mainWindow = new BrowserWindow({
          width:500,
          height:500,
          alwaysOnTop:true,
          webPreferences:{
            preload:path.resolve(__dirname,'preload.js')，
            contextIsolation: false,
            nodeIntegration:true,
            sandbox:false
          },
        })
        mainWindow.webContents.openDevTools()
      }
  
  
  
  	取消隔离（preload与render）：mainWindow中设置webPreference的contextIsolation false
  	取消node限制（preload和render都可使用node）：同上，nodeIntegration true
  	全部开开后安全系数大大降低
  	
  	仅开启preload限制(包括node和electorn的限制）：同上，关掉沙盒模式，sandbox false
  	
  其它命令：
  	mainWindow.center()   mainWindow.fullscreen()
  	fullscreen center 
  	可通过异步修改
  	拖拽：mainWindow.setBounts（{},true） true表示有动画过度
  	获取屏幕尺寸：screen.getPrimaryDisplay().workAreaSizde
  	获取窗口：const win = BrowserWindow.fromWebContents(event.sender)
  ```
  
  ```
  
  ```
  
  
  
  - nodemon  解决开发dev热更新
  
    ```
    nodemon --exec [dev construction]
    
    默认只监测js
    配置监测html:
    	{
      "ignore":[
        "node_modules",
        "dist"
      ],
      "colours":true,
      "verbose":"rs",
      "watch":[
        "*.*"
      ],
      "ext":"html,js"
    }
    ```
  
  - concurrently——dev中同时启动多个命令
  
    ```
    ~~ concurrently
    
    electron中同时启动vite和electron
    ```
  

---

## Three

重要概念

- 画布 Scene

  ```
  创建画布
  
  const scene = new THREE.Scene();
  ```

  

- 摄像机 Cam

  ```
  设置摄像机
  
  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  ---
  设置z轴
  camera.position.z = 5;
  ```

  

- 渲染器 Render

  ```
  创建渲染器
  
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  ```

  

- 物体 Object

  - 类型

    ```
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    ```

    

  - 材质

    ```
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    ```

  - 物体

    ```
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    
    const cube = new THREE.Mesh(geometry, material);
    // 获取位置
    cube.position.x
    cube.position.y
    cube.position.z
    // 修改位置
    cube.position.set(0, 0, 0);
    // 设置缩放
    cube.scale.set(1, 1, 1);
    // 设置旋转
    cube.rotation.set(Math.PI / 4, Math.PI / 4, Math.PI / 4， "XYZ");
    // 添加到画布
    scene.add(cube);
    ```

- 控制器

  ```
  const controls = new OrbitControls(camera, renderer.domElement);
  ```

- 时钟Clock

  ```
  // 创建
  const clock = new THREE.Clock();
  // 属性
  .autoStart    设置为true后，第一次update时开启时钟
  .startTime    存储最后一次调用start方法的时间
  .oldTime	  存储时钟最后一次调用start,getElapsedTime或getDelta方法的时间
  .elapsedTime  保存运行时钟的总时长
  .running      是否在运行
  // 方法
  .start             启动并且设置startTime && oldTime为当前时间，设置elapsedTime为0，设置running为true
  .stop              停止并设置oldTime为当前时间
  ⭐.getElapsedTime    获取时钟启动后的秒数，设置oldTime设置为当前时间
  ⭐.getDelta         获取从oldTime设置后到当前的秒数，即间隔时间
  ```

- 标注辅助器

  ```
  const axesHelper = new THREE.AxesHelper(10);
  scene.add(axesHelper);
  ```

- 请求动画帧

  ```
  let step = 0
  // args t为绝对时间，文档加载完毕后进行计算， 不过一般用Clock跟踪时间对象
  function animate(t) {
    const time = clock.getElapsedTime();
    const deltaTime = clock.getDelta();
    // 距离=速度*时间
    cube.position.x = t * 1
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  
  animate();
  ```

  - GSAP

    ```
    安装： npm install gsap
    导入：import gsap from 'gsap'
    设置动画: 
    	gsap.to(cube.position, { x: 10, duration: 1, ease: "power1.inOut" });
    	gsap.to(cube.rotation, { x: Math.PI * 4, duration: 1, ease: "power1.inOut" });
    动画+事件：
    const animate1 = gsap.to(cube.position, {
      x: 10,
      duration: 1,
      ease: "power1.inOut",
      repeat: -1,
      yoyo: true,
      onComplete: () => {
        console.log("动画结束");
      },
      onStart: () => {
        console.log("动画开始");
      },
    });
    window.addEventListener("dblclick", () => {
      animate1.isActive() ? animate1.pause() : animate1.resume();
    });
    ```

    

  

# GPT相关

- 文档

  ```
  - A well-written prompt provides enough information for the model to know what you want and how it should respond.
  - default models' training data cuts off in 2021
  -  if all the returned samples have finish_reason == "length", it's likely that max_tokens is too small and model runs out of tokens before it manages to connect the prompt and the suffix naturally. Consider increasing max_tokens before resampling.
  
  Basics
  There are three basic guidelines to creating prompts:
  Show and tell. Make it clear what you want either through instructions, examples, or a combination of the two. If you want the model to rank a list of items in alphabetical order or to classify a paragraph by sentiment, show it that's what you want.
  Provide quality data. If you're trying to build a classifier or get the model to follow a pattern, make sure that there are enough examples. Be sure to proofread your examples — the model is usually smart enough to see through basic spelling mistakes and give you a response, but it also might assume this is intentional and it can affect the response.
  Check your settings. The temperature and top_p settings control how deterministic the model is in generating a response. If you're asking it for a response where there's only one right answer, then you'd want to set these lower. If you're looking for more diverse responses, then you might want to set them higher. The number one mistake people use with these settings is assuming that they're "cleverness" or "creativity" controls.
  ```

- 重要参数

  ```
  重要参数：
  	给予的数据，数据源。数量是否够多，质量是否够大
  	Settings，是否设置正确，是想要聚还是想要散
  	
  影响确定性（信息的聚散）
  	temperature   0越确定（deterministic）  数值越高可能性越多
  	top_p  同上
  影响内容链接度/断裂
  	 max_tokens  越大发送的信息越多。过小会导致信息断裂
  	
  
  
  
  finish_reason == 'stop'
  resample >= 3 && resample <= 5  (or using best_of with k=3,5)
  
  endpoint——给出需要遵循的模式，并且确定何时停止
  
  提供额外的确切信息——优先级
  	Extra Message（EM） to help GPT better understand————为model提供有用的上下文
  	
  
  ```
  
- Response format

  ```
  最后返回的信息就是response['choices'][0]['message']['content']
  返回信息：
  {
   'id': 'chatcmpl-6p9XYPYSTTRi0xEviKjjilqrWU2Ve',
   'object': 'chat.completion',
   'created': 1677649420,
   'model': 'gpt-3.5-turbo',
   'usage': {'prompt_tokens': 56, 'completion_tokens': 31, 'total_tokens': 87},
   'choices': [
     {
      'message': {
        'role': 'assistant',
        'content': 'The 2020 World Series was played in Arlington, Texas at the Globe Life Field, which was the new home stadium for the Texas Rangers.'},
      'finish_reason': 'stop',
      'index': 0
     }
    ]
  }
  ```

  ```
  参数详解：
  finish_reason：
  	stop: API returned complete model output
  	length: Incomplete model output due to max_tokens parameter or token limit
  	content_filter: Omitted content due to a flag from our content filters
  	null: API response still in progress or incomplete
  ```

  ```
  Token管理：
  Language models read text in chunks called tokens. In English, a token can be as short as one character or as long as one word (e.g., a or apple), and in some languages tokens can be even shorter than one character or even longer than one word.
  For example, the string "ChatGPT is great!" is encoded into six tokens: ["Chat", "G", "PT", " is", " great", "!"].
  
  token越大，开销越大
  token越大，花费时间越长，内容越匹配
  token最大4096
  
  输入和输出都记作token:
  	Both input and output tokens count toward these quantities. For example, if your API call used 10 tokens in the message input and you received 20 tokens in the message output, you would be billed for 30 tokens.
  
  查看token：response['usage']['total_tokens']
  
  ```
  
  ```
  图片生成：
  	基于文字——文生图
  	基于现有的图片结果进行调整——图生图
  	根据现有图像生成图像——图生图
  	
  	描述：
  		图片主体：
  		图片主体的物理性质：
  		人的评价和反映：
  ```
  
  ```
  微调 fine——tuning
  	
  ```
  
  

# GPT话术

---

- 1

  ```
  表述自己目前的状态：
  	1、我不太清楚
  	2、我很明确
  表述输出格式：
  	例：以JSON格式输出
  引导模型一步步思考，像人类一样。人类不会一下子思考完所有的东西
  ```

- 2

  ```
  常用数据属性：
  	唯一认证：id
  	数据分析：
  		总价
  		最高与最低
  		均值
  		中位数
  		方差
  ```

  

- 文字处理————调查报告、xx分析

  ```
  给我写一篇关于xxx的市场调查背景的报告
  	以xxx为主
  要求：
  	在范围方面：xx范围内的xxxxx
  	在数据方面：借助权威的大数据平台或专业分析网站等；数据来源要真实可靠，并标注数据出处。
  	在字数方面：字数不少于800字。
  	在详细度方面：要求内容尽可能详尽，细致完整。
  	在表述方面：通过客观语言和事实进行表述，逻辑清晰。
  	在方法方面：使用多种专业且流行的分析工具
  	在分析方面：运用多种分析的角度和方法，给出极致且令人信服的内容。
  	在总结方面：对内容做一个总结。
  	身份：以A股融资集团CEO的身份
  ```

- 代码处理————生成SQL数据

  ![image-20230401104021689](C:\Users\16193\AppData\Roaming\Typora\typora-user-images\image-20230401104021689.png)

- 回答问题————

- 学习辅导————

- 私人助理————



