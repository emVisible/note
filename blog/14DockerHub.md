# 14DockerHub

---

之前我们提到了Dockerfile的部分语法，而在实际使用中，对于Dockerfile往往不是从零开始搭建。

和各种编程语言的包一样，我们学习完语法之后在实际使用中往往不会使用我们自己做的算法等功能，而是使用其它人或者其它团队提供的包或者模块，它们往往经历了实际应用的检验，考虑到了各种实际情况，拥有足够的易用性和壮健性。

## 镜像版本

我们最终需要的镜像，是软件版本符合的镜像。

在DockerHub提供的镜像中，镜像提供者会提供该镜像的不同版本的tag。tag包括了OpenJDK版本，OS以及开发者等信息。

## Alpine

在镜像的tag中，我们经常能看到Alpine。Alpine是基于Alpine Linux的文件操作系统，嵌入于镜像内。

其大小仅为不到两位数的MB量级。远远小于其它的Linux OS。任何东西到了轻量级和小规模，优势和劣势都是可以类比的。Alpine非常适合Docker这种虚拟化方案，使得容器的资源占用可以达到足够小。缺点就是没有更多的功能，就好比手机和台式机，手机要想实现台式机的基本功能，需要自己配置很多东西。

当需要基于Linux进行二次封装时，更好的选择是使用相对完善和成熟的CentOS、Ubuntu、Debian等。

## 容器配置

利用Docker的ENTRYPOINT和CMD的语法，我们可以编写一个自动化的环境配置，省去繁琐且重复的初始化操作。

我们可以在镜像提供者的仓库找到对应的自动化脚本，它们由镜像提供者维护，并且拥有相对完善的doc。

其使用和开发中的大部分模块、工具类等类似，通过CLI。

```
docker run ...
```

而具体的实现机制，在其对应的Dockerfile中可以看到具体编写方法和逻辑。

## 镜像共享

镜像共享操作十分简单

```
在DockerHub中 => Create Automated Build 
```

通过自动构建，DockerHub会在云上构建镜像。构建完毕后就可以通过docker pull拉取镜像

```
docker pull xxx
```

DockerHub不直接存放Dockerfile配置文件以及具体文件，需要到Github等仓库中获取。



